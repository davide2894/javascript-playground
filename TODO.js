/*
Hi friends :slightly_smiling_face:

Now the problem of the day :grinning:, it is easy, do not worry :grinning:

Write a function that takes an array as argument, and returns true or false depending on the following

Returns true if the first half of the array is containing the same elements present in the last half, and false if it does not

If the array contains odd number elements ,the function returns true if the two parts around the middle element contain the same elements

Elements in the two parts are not necessary to be in the same order

For example

check([1,4,6,8,8,6,1,4]); // true
check(["a","b","d","g","f","b","g","d","a"])  // true
check(["a","b","d","g","f","b","g","f","a"]);// false
check([10,20,30,40,10,20,50])  // false
*/





shiftCapital("fRiends", 7)
str[indexToGo] R
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] R
fRiends

str[indexToGo] i
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] i
fiRends

str[indexToGo] e
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] e
fieRnds

str[indexToGo] n
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] n
fienRds

str[indexToGo] d
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] d
fiendRs

str[indexToGo] f
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] f
Riendfs

str[indexToGo] i
str[capitalIndex] R
swap
new str[indexToGo] R
new str[capitalIndex] i
iRendfs

"iRendfs"
